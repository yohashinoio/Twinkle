[[nomangle]]
declare func printf(format: ^i8, ...) -> i32;

declare struct numnode;

struct numnode {
  let mut n: i32;
  let mut next: ^numnode;
}

struct numlist {
  numlist()
  {
    head = new numnode;
    head^.next = 0 as ^numnode;

    size = 0;
  }

  ~numlist()
  {
    while (head^.next != 0 as ^numnode) {
      let tmp = head;
      head = head^.next;
      delete tmp;
    }
  }

  func push_back(val: i32)
  {
    let mut tail = search_tail();

    let newnode = new numnode;

    newnode^.n = val;
    newnode^.next = 0 as ^numnode;

    tail^.next = newnode;

    ++size;
  }

  func pop_back()
  {
    let tail = search_tail();

    let mut p = head^.next;

    let mut tmp = head;
    while (p != tail) {
      tmp = p;
      p = p^.next;
    }

    tmp^.next = 0 as ^numnode;
    delete p;

    --size;
  }

  func at(idx: i32) -> i32
  {
    let mut p = head^.next;

    for (let mut i = 0; i != idx; ++i)
      p = p^.next;

    return p^.n;
  }

  func size() -> i32
  {
    return size;
  }

private:
  func search_tail() -> ^numnode
  {
    let mut p = head;

    while (p^.next != 0 as ^numnode)
      p = p^.next;

    return p;
  }

  let mut head: ^numnode;

  let mut size: i32;
}

func main() -> i32
{
  let elems = [48, 10, 4, 8, 1, 0, 58];

  let linked_list = numlist{};

  for (let mut i = 0; i < sizeof elems / sizeof elems[0]; ++i)
    linked_list.push_back(elems[i]);

  linked_list.pop_back();

  for (let mut i = 0; i < linked_list.size(); ++i)
    printf("%d\n", linked_list.at(i));
}
